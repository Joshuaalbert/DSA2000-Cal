# Folder structure of container:
# /data has MS files
# /logs has logs
# /gains has solutions

input_ms:
  path: /data/W-32chan-10-5s.ms
  data_column: DATA
  weight_column: WEIGHT_SPECTRUM
  time_chunk: 1 # Controls how much RAM is used, can be unit or number per chunk
  freq_chunk: 1 # can be unit or number per chunk
  select_corr: [ 0,1,2,3 ] # All correlations
  select_fields: [ 0 ]
  select_ddids: [ 0 ] # spectral windows of MS
  select_uv_range: [ 100, 0 ] # use 0 as open end

input_model:
  recipe: MODEL_DATA
  source_chunks: 1 # big impact on RAM

output:
  gain_directory: /gains/W-32chan-10-5s
  log_directory: /logs/W-32chan-10-5s
  log_to_terminal: True
  overwrite: False
  products: [ corrected_residual, corrected_weight ]
  columns: [ CORRECTED_DATA, WEIGHT_SPECTRUM ] # one for each product
  flags: True

dask:
  threads: 0 # Setting to zero (the default) will use all available resources.
  scheduler: "threads" # Apparently "threads" is best for single-node use. "multiprocessing" would be the other.

solver:
  terms: [ "G" ]
  iter_recipe: [ 25 ] # Using a zero would just "interpolate" the solutions into appropriate gains, e.g. G (independent) -> dE (dependent)
  propagate_flags: True
  robust: False # reweight visibilties using residuals (or something) Ask about it.
  threads: 1 # The total number of threads used will be dask.threads*solver.threads; if this product exceeds the number of available threads, performance will suffer.
  convergence_criteria: 0.0 # Like x_tol. The change in the value of the gain below which it considered to have converged. Set to zero to iterate for the number of interations specified in solver.iter_recipe.
  convergence_fraction: 1.0 # The fraction of gain values which must converge before a solver will exit prematurely.
  reference_antenna: 0 # reference antenna. No gaurantee that it'll be zero.

G:
  type: phase
  time_interval: "1"
  freq_interval: "1"