input_ms:
  path: path/to.ms
  data_column: DATA
  sigma_column: SIGMA_WEIGHT # Preferred over weight_column
  #    weight_column: WEIGHT_SPECTRUM
  time_chunk: 1 # Controls how much RAM is used, can be unit or number per chunk
  freq_chunk: 80 # can be unit or number per chunk
  #    is_bda: False # If baseline averaging has happened turn on
  #    group_by: [SCAN_NUMBER, FIELD_ID, DATA_DESC_ID] # Unsure when to use
  select_corr: [ 0,1,2,3 ] # All correlations
  select_fields: [ 0 ]
  select_ddids: [ 0 ] # spectral windows of MS
  select_uv_range: [ 100, 0 ] # use 0 as open end

input_model:
  recipe: LSM1@dE
  #    beam: beam_$(corr)_$(reim).fits # if beam needs to be applied
  #    beam_l_axis:
  #    beam_m_axis:
  #    invert_uvw: True # True by default for CASA convention
  source_chunks: 1 # big impact on RAM
#    apply_p_jones: False # Only important for polarisation
#Q_corr = Q * cos(2P) + U * sin(2P)
#U_corr = -Q * sin(2P) + U * cos(2P)

output:
  gain_directory: /gains
  log_directory: /logs
  log_to_terminal: True
  overwrite: False
  products: [ residual, corrected_residual ]
  columns: [ COL1, COL1 ] # one for each product
  flags: True
  #    apply_p_jones_inv: False # not sure about this
  net_gains: [ [ "G", "dE" ] ]
#    subtract_directions:
#    compute_baseline_corrections: False # Might be interesting to see
#    apply_baseline_corrections: False

mad_flags:
  enable: False
  whitening: "native" # “native” whitening will use the original weights (specified in the input_ms section). “robust” will use the weights produced when solver.robust=True. “disabled” will result in the MAD estimate being performed on the unwhitened residuals.
  threshold_bl: 5 # similar as global but over baseline and not data chunk.
  threshold_global: 3 # Over entire data chunk chi-square: chi-square > MAD*threshold_global
  max_deviation: 3 # If the MAD estimate over all baselines is X, and the MAD estimate on a specific baseline is X_bl, baselines for which X_bl > max_deviation*X will be flagged.

dask:
  threads: 0 # Setting to zero (the default) will use all available resources.
  #  workers: #Number of workers to use in the dask distributed scheduler. Advanced users only.
  #  address: # distributed scheduler address (only useful for distributed job)
  scheduler: "threads" # Apparently "threads" is best for single-node use. "multiprocessing" would be the other.

solver:
  terms: [ "K", "B", "G_allband" ]
  iter_recipe: [ 0,10,10, 10,10,10 ] # Using a zero would just "interpolate" the solutions into appropriate gains, e.g. G (independent) -> dE (dependent)
  propagate_flags: True
  robust: False # reweight visibilties using residuals (or something) Ask about it.
  threads: 1 # The total number of threads used will be dask.threads*solver.threads; if this product exceeds the number of available threads, performance will suffer.
  convergence_criteria: 0.0 # Like x_tol. The change in the value of the gain below which it considered to have converged. Set to zero to iterate for the number of interations specified in solver.iter_recipe.
  convergence_fraction: 1.0 # The fraction of gain values which must converge before a solver will exit prematurely.
  reference_antenna: 0 # reference antenna. No gaurantee that it'll be zero.

K:
  type: "delay"
  time_interval: "1"
  freq_interval: "0"


G_allband:
  type: "complex"
  time_interval: "1"
  freq_interval: "0"

B:
  type: "complex"
  time_interval: "0"
  freq_interval: "1"


#G:
#  type: "complex"
#  #  solve_per: # options not specified
#  direction_dependent: False
#  time_interval: "1" # I guess should be factor of time_chunk
#  freq_interval: "0" # I guess should be a factor of freq_chunk
#  respect_scan_boundaries: False # This only works when input_ms.group_by does not include SCAN_NUMBER.
#  # Can be used in conjunction with time_interval to solve a term per scan even when data is not partitioned by scan (by setting this to True and time_interval to 0).
#  initial_estimate: True # Obviously use this
#  load_from: # I guess needed for initial_estimate?
##  interp_mode: "nearest" # unspecified options ("nearest"?)
##  interp_method: # not even sure how this is different
